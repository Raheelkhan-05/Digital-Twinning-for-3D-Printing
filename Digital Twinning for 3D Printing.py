# -*- coding: utf-8 -*-
"""CV_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18TUyh9pWEbtB9LLuB9HpAKSCGLc1mr0o
"""

import os
import cv2
import subprocess
import json
import numpy as np
import shutil
import time
import matplotlib.pyplot as plt
import logging
import psutil
import platform
import socket
from datetime import datetime

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("nerf_reconstruction")

def check_system_resources():
    print("\n[System Check] Verifying environment...")
    total, used, free = shutil.disk_usage("/")
    logger.info(f"Disk space available: {free // (2**30)} GB")

    try:
        import torch
        if torch.cuda.is_available():
            logger.info(f"CUDA is available on: {torch.cuda.get_device_name(0)}")
        else:
            logger.warning("CUDA not available. Training may be slow.")
    except ImportError:
        logger.warning("PyTorch not installed. Skipping CUDA check.")

    logger.info(f"CPU: {platform.processor()}")
    logger.info(f"RAM: {round(psutil.virtual_memory().total / (1024 ** 3), 2)} GB")

class SimpleNeRFReconstructor:
    """Simplified Neural Radiance Fields reconstruction class"""

    def __init__(self, config):
        """Initialize with configuration parameters"""
        self.video_path = config["video_path"]
        self.project_dir = config["project_dir"]
        self.ngp_path = config["ngp_path"]
        self.sample_rate = config["sample_rate"]
        self.training_time = config["training_time"]
        self.mesh_resolution = config.get("mesh_resolution", 256)

        self.project_name = "nerf_scene"
        self.project_dir = os.path.join(self.project_dir, self.project_name)
        os.makedirs(self.project_dir, exist_ok=True)

        self.frames_dir = os.path.join(self.project_dir, "frames")
        self.masked_dir = os.path.join(self.project_dir, "masked")
        self.export_dir = os.path.join(self.project_dir, "exports")

        os.makedirs(self.frames_dir, exist_ok=True)
        os.makedirs(self.masked_dir, exist_ok=True)
        os.makedirs(self.export_dir, exist_ok=True)

        self.ngp_scene_dir = os.path.join(self.ngp_path, "data", self.project_name)
        os.makedirs(self.ngp_scene_dir, exist_ok=True)

        self.stats = {"frame_count": 0, "start_time": time.time()}

    def extract_frames(self):
        logger.info(f"Extracting frames from: {self.video_path}")
        if not os.path.exists(self.video_path):
            raise FileNotFoundError(f"Video file not found: {self.video_path}")

        cap = cv2.VideoCapture(self.video_path)
        if not cap.isOpened():
            raise IOError("Failed to open video file")

        fps = cap.get(cv2.CAP_PROP_FPS)
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        frame_interval = max(1, int(fps / self.sample_rate))

        logger.info(f"Video properties: {fps:.2f} FPS, {total_frames} frames")
        logger.info(f"Using frame interval of {frame_interval}")

        frames_saved, frame_count = 0, 0
        preview_shown = False

        while True:
            ret, frame = cap.read()
            if not ret:
                break

            if frame_count % frame_interval == 0:
                output_path = os.path.join(self.frames_dir, f"frame_{frames_saved:04d}.png")
                cv2.imwrite(output_path, frame)
                frames_saved += 1
                if not preview_shown:
                    cv2.imshow("Sample Extracted Frame", frame)
                    cv2.waitKey(1000)
                    cv2.destroyAllWindows()
                    preview_shown = True

            frame_count += 1
            if frame_count % (total_frames // 10) == 0:
                logger.info(f"Progress: {(frame_count / total_frames) * 100:.1f}%")

        cap.release()
        self.stats["frame_count"] = frames_saved
        logger.info(f"Extracted {frames_saved} frames")
        return frames_saved

    def segment_objects(self):
        logger.info("Performing background removal")
        try:
            subprocess.run([
                "rembg", "p", "--model", "u2net",
                self.frames_dir, self.masked_dir
            ], check=True)
            masked_files = os.listdir(self.masked_dir)
            logger.info(f"Generated {len(masked_files)} masked frames")
        except subprocess.CalledProcessError as e:
            logger.error(f"Background removal failed: {str(e)}")
            raise
        return len(os.listdir(self.masked_dir))

    def run_colmap(self):
        logger.info("Running COLMAP for camera pose estimation")
        script_path = os.path.join(self.ngp_path, "scripts", "colmap2nerf.py")
        if not os.path.exists(script_path):
            raise FileNotFoundError(f"colmap2nerf.py not found at: {script_path}")

        command = [
            "python", script_path,
            "--colmap_matcher", "exhaustive",
            "--run_colmap",
            "--aabb_scale", "32",
            "--images", self.frames_dir,
            "--out", os.path.join(self.ngp_scene_dir, "transforms.json"),
            "--overwrite"
        ]

        try:
            subprocess.run(command, check=True)
            self._update_transforms_file()
            self.validate_transforms()
            logger.info("COLMAP processing completed")
        except subprocess.CalledProcessError:
            logger.error("COLMAP processing failed")
            raise

    def _update_transforms_file(self):
        transforms_path = os.path.join(self.ngp_scene_dir, "transforms.json")
        if not os.path.exists(transforms_path):
            logger.error("transforms.json not found")
            return False

        logger.info("Updating transforms.json with masked frame paths")
        frames_dir = os.path.join(self.ngp_scene_dir, "frames")
        os.makedirs(frames_dir, exist_ok=True)

        for file in os.listdir(self.masked_dir):
            shutil.copy(os.path.join(self.masked_dir, file), os.path.join(frames_dir, file))

        with open(transforms_path, "r") as f:
            data = json.load(f)

        updated = 0
        for frame in data.get("frames", []):
            if "file_path" in frame:
                orig_filename = os.path.basename(frame["file_path"])
                frame["file_path"] = os.path.join("frames", orig_filename).replace("\\", "/")
                updated += 1

        with open(transforms_path, "w") as f:
            json.dump(data, f, indent=4)

        logger.info(f"Updated {updated} frame paths in transforms.json")
        return True

    def validate_transforms(self):
        transforms_path = os.path.join(self.ngp_scene_dir, "transforms.json")
        try:
            with open(transforms_path, "r") as f:
                data = json.load(f)
            assert "frames" in data and isinstance(data["frames"], list)
            logger.info("transforms.json validated successfully.")
        except Exception as e:
            logger.warning(f"transforms.json validation issue: {e}")

    def train_nerf(self):
        logger.info("Starting Neural Radiance Field training")
        ngp_exe = os.path.join(self.ngp_path, "instant-ngp.exe")
        if not os.path.exists(ngp_exe):
            raise FileNotFoundError(f"instant-ngp.exe not found at {ngp_exe}")

        rel_scene_path = os.path.relpath(self.ngp_scene_dir, self.ngp_path).replace("\\", "/")
        training_steps = int(self.training_time * 6000)

        command = [ngp_exe, "--scene", rel_scene_path]
        logger.info(f"Training for {self.training_time} minutes ({training_steps} steps)")

        try:
            process = subprocess.Popen(command, cwd=self.ngp_path)
            end_time = time.time() + (self.training_time * 60)
            while time.time() < end_time and process.poll() is None:
                mins, secs = divmod(int(end_time - time.time()), 60)
                print(f"\rTraining: {mins:02d}:{secs:02d} remaining...", end="")
                time.sleep(1)
            print("\nTraining completed!")
            print("\nPlease export the mesh and close Instant-NGP. (Press Ctrl+C when done)")
            try:
                process.wait()
            except KeyboardInterrupt:
                print("\nContinuing...")
                if process.poll() is None:
                    process.terminate()
        except Exception as e:
            logger.error(f"Training failed: {str(e)}")
            raise

    def plot_frame_counts(self, extracted, masked):
        plt.figure(figsize=(6, 4))
        plt.bar(["Extracted", "Masked"], [extracted, masked], color=["skyblue", "lightgreen"])
        plt.title("Frame Count Comparison")
        plt.ylabel("Number of Frames")
        plt.savefig(os.path.join(self.project_dir, "frame_stats.png"))
        plt.close()
        logger.info("Frame count comparison chart saved.")

    def create_summary(self):
        summary_path = os.path.join(self.project_dir, "summary.md")
        with open(summary_path, "w") as f:
            f.write("# NeRF Reconstruction Summary\n\n")
            f.write(f"Project: {self.project_name}\n")
            f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"- Processing Time: {(time.time() - self.stats['start_time']) / 60:.2f} minutes\n")
            f.write(f"- Frames Processed: {self.stats['frame_count']}\n")
            f.write(f"- Source Video: {os.path.basename(self.video_path)}\n\n")
            f.write("## Results\n")
            f.write("Check the exports directory and frame_stats.png for outputs.\n\n")
            f.write("## System Information\n")
            f.write(f"- Hostname: {socket.gethostname()}\n")
            f.write(f"- CPU: {platform.processor()}\n")
            f.write(f"- RAM: {round(psutil.virtual_memory().total / (1024 ** 3), 2)} GB\n")
        logger.info(f"Summary created at: {summary_path}")
        return summary_path

    def run_pipeline(self):
        try:
            print("=" * 70)
            print(" NEURAL 3D RECONSTRUCTION PIPELINE ".center(70, "="))
            print("=" * 70)

            extracted = self.extract_frames()
            masked = self.segment_objects()
            self.plot_frame_counts(extracted, masked)
            self.run_colmap()
            self.train_nerf()
            self.create_summary()

            print("\n" + "=" * 70)
            print(" RECONSTRUCTION COMPLETED SUCCESSFULLY ".center(70, "="))
            print("=" * 70)
            print(f"Project directory: {self.project_dir}")
            print(f"Total time: {(time.time() - self.stats['start_time']) / 60:.2f} minutes")
            print("=" * 70)

            return True
        except Exception as e:
            logger.error(f"Pipeline failed: {str(e)}")
            print(f"\nERROR: {str(e)}")
            return False


if __name__ == "__main__":
    config = {
        "video_path": r"C:\Users\rahee\Downloads\drone.mp4",
        "project_dir": r"C:\Users\rahee\Downloads\nerf_project",
        "ngp_path": r"C:\Users\rahee\Downloads\Instant-NGP-for-RTX-3000-and-4000\Instant-NGP-for-RTX-3000-and-4000",
        "sample_rate": 3,
        "training_time": 2,
        "mesh_resolution": 256
    }

    check_system_resources()

    if os.path.exists(config["video_path"]) and os.path.exists(config["ngp_path"]):
        reconstructor = SimpleNeRFReconstructor(config)
        reconstructor.run_pipeline()
    else:
        print("Please fix the path errors and try again.")

